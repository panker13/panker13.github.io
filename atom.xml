<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://panker13.github.io</id>
    <title>Panker</title>
    <updated>2021-03-23T15:59:43.181Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://panker13.github.io"/>
    <link rel="self" href="https://panker13.github.io/atom.xml"/>
    <subtitle>春天的原野里，你一个人正走着，对面走来了一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说:你好，小姐，和我一块儿打滚玩好吗？接着，你就和小熊一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一天。</subtitle>
    <logo>https://panker13.github.io/images/avatar.png</logo>
    <icon>https://panker13.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Panker</rights>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://panker13.github.io/post/hello-gridea/</id>
        <link href="https://panker13.github.io/post/hello-gridea/">
        </link>
        <updated>2021-03-23T11:39:35.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于搭建个人博客的经验]]></title>
        <id>https://panker13.github.io/post/guan-yu-da-jian-ge-ren-bo-ke-de-jing-yan/</id>
        <link href="https://panker13.github.io/post/guan-yu-da-jian-ge-ren-bo-ke-de-jing-yan/">
        </link>
        <updated>2021-03-23T11:11:19.000Z</updated>
        <summary type="html"><![CDATA[<p>在我用简单的方法失败了一次后，我终于用更简单的方法搭建好了我的第一个个人博客😝233</p>
]]></summary>
        <content type="html"><![CDATA[<p>在我用简单的方法失败了一次后，我终于用更简单的方法搭建好了我的第一个个人博客😝233</p>
<!-- more -->
<h2 id="在210323的下午翘了体育课">在21.03.23的下午翘了体育课</h2>
<p>这无疑是我翘过最正确的一节课了😎。其实，搭建个人博客是我上学期就一直向干的事情了（主要是受到了许多博客的可爱的看板娘的<s>诱惑</s>，并且看到yyh同学的博客，我直接心生艳羡之意），所以我其实寒假在家已经尝试过利用Github托管服务与Hexo框架搭建个人博客了，但，，，失败了。但但，天无绝人之路，在某天的中午（对，就是上面的日期），我了解到了Gridea这个自助式搭建博客神器，成功拯救了我这个<s>手残党</s></p>
<h2 id="寒假的尝试">寒假的尝试</h2>
<p>在寒假，我用了整整一天的时间来了解Git、Node、Hexo等等（虽然现在都已经忘得差不多了），去尝试注册Github的仓库，初始化一个博客等等（这些都成功了，也算是有所收获），但是，却在将初始化的博客内容推送到Github上的时候失败了（现在想来可能是Github在国内的网络连接不稳定）。然后我把所有的Git、Node等软件全部删除了然后重装，如此反复三次，结果都gg了，唉😔。到现在还是nodejs下的某个组件安装失败，疑问仍未解决</p>
<h2 id="gridea">Gridea</h2>
<p>这软件可好，<s>傻瓜</s>自助式搭建博客助手（不过好像要备份，因为一换电脑，上面的内容就消失了），具体用法百度吧，哈哈，我累了，现在在上自习课（19：34），我还要写算法题呢，嘿嘿😁，再见，下次再聊（如果有下次的话）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法学习：从poj上的Fliptile到开关问题]]></title>
        <id>https://panker13.github.io/post/suan-fa-xue-xi-cong-poj-shang-de-fliptile-dao-kai-guan-wen-ti/</id>
        <link href="https://panker13.github.io/post/suan-fa-xue-xi-cong-poj-shang-de-fliptile-dao-kai-guan-wen-ti/">
        </link>
        <updated>2021-03-23T10:28:16.000Z</updated>
        <summary type="html"><![CDATA[<p>是一个关于二进制枚举以及模拟递推的小问题😳</p>
]]></summary>
        <content type="html"><![CDATA[<p>是一个关于二进制枚举以及模拟递推的小问题😳</p>
<!-- more -->
<h3 id="写在前面本人蒟蒻写此分享来督促自己复习并与大家分享有关开关问题的一些技巧以及例题代码">写在前面：本人蒟蒻，写此分享来督促自己复习，并与大家分享有关开关问题的一些技巧以及例题代码</h3>
<p><a href="http://poj.org/problem?id=3279">Fliptile题目链接</a><br>
<a href="https://yq.aliyun.com/articles/267150">参考题解</a><br>
<a href="https://blog.csdn.net/ac_hell/article/details/51077320">翻转问题的主要技巧以及规律</a></p>
<h3 id="详细内容见代码及注释">详细内容见代码及注释</h3>
<h3 id="代码如有疏漏之处敬请指出">代码（如有疏漏之处，敬请指出）😁</h3>
<pre><code>//先用状态压缩的方法枚举第一行的翻转情况，然后通过第一行的情况来递推出第二行的情况
//即：已知了第一行的情况了，需要通过第二行来修正第一行的情况
//（因为第一行已经被枚举固定了，所以除了第二行之外，其他行无法修改第一行）
//以此类推：其他所有行的情况都可以被递推出（即：是已经固定的了）
//注意：除了最后一行，因为没有最后一行没有下一行来帮最后一行修正
//(所以最后一行也是固定的，无法修正，最后应该检查一下最后一行是否符合题意即可)
//关键是：由下一行来处理上一行（而且是垂直的上一行，因为只有垂直的上一行是固定的）

# include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 20;
const int INF = 0x3f3f3f3f;

int n, m;
int a[N][N];            //原始数组
int b[N][N];            //保存翻转次数的数组
int c[N][N];            //记录答案的数组
int dx[] = {0, 1, 0, -1, 0}, dy[] = {0, 0, -1, 0, 1};   //其实棋子并不受下方棋子的影响

bool out(int x, int y)
{
    if(x &lt; 0 || x &gt;= n|| y &lt; 0 || y &gt;= m)  return true;
    else  return false;
}

int get_color(int x, int y)
{
    int color = a[x][y];                                //初始颜色（这里是a）
    for(int i=0; i&lt;5; ++i)
    {
        int nx = x + dx[i], ny = y + dy[i];
        if(out(nx, ny))  continue;
        color += b[nx][ny];                             //这里是b
    }
    return color &amp; 1;                                   //本层翻转后的颜色（是固定的）
    //翻转后的颜色等于初始颜色+翻转影响产生的颜色（上，下，左，右，中五个方向）
}

int flip(int s)
{
    for(int i=1; i&lt;=m; ++i)  b[0][i-1] = (s&gt;&gt;(m-i)) &amp; 1;
    
    for(int i=1; i&lt;n; ++i)
    {
        for(int j=0; j&lt;m; ++j)
        {
            if(get_color(i-1, j))   b[i][j] = 1;  
            //由上一行的状态来递推出下一行的状态，因为上一行的上，左，右状态已经全部已知
            //而正是由上方的状态来递推出其下方的状态
        }
    }
    
    for(int i=0; i&lt;m; ++i)   if(get_color(n-1, i))   return INF;        //检查最后一层
    
    int times = 0;
    for(int i=0; i&lt;n; ++i)   for(int j=0; j&lt;m; ++j)  times += b[i][j];  //得出最小翻转次数
    return times;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=0; i&lt;n; ++i)  for(int j=0; j&lt;m; ++j)   cin&gt;&gt;a[i][j];
    
    int ans = INF;
    //枚举的是第一行所有可能的翻转动作（即：翻(1)或不翻(0)）
    for(int i=0; i &lt; (1&lt;&lt;m); ++i)        //状态压缩，枚举第一行所有可能的情况 ，后面的只需递推了
    {
        memset(b, 0, sizeof b);         //记得初始化b
        int t = flip(i);
        if(t &lt; ans)
        {
            ans = t;
            memcpy(c, b, sizeof b);     //复制状态
        }
    }
    
    if(ans == INF)  cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl;
    else
    {
        for(int i=0; i&lt;n; ++i)
        {
            for(int j=0; j&lt;m; ++j)
            {
                cout&lt;&lt;c[i][j]&lt;&lt;' ';
            }
            cout&lt;&lt;endl;
        }
    }
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>