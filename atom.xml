<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://panker13.github.io</id>
    <title>Panker</title>
    <updated>2021-11-04T15:55:04.658Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://panker13.github.io"/>
    <link rel="self" href="https://panker13.github.io/atom.xml"/>
    <subtitle>春天的原野里，你一个人正走着，对面走来了一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说:你好，小姐，和我一块儿打滚玩好吗？接着，你就和小熊一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一天。</subtitle>
    <logo>https://panker13.github.io/images/avatar.png</logo>
    <icon>https://panker13.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Panker</rights>
    <entry>
        <title type="html"><![CDATA[LanQiao]]></title>
        <id>https://panker13.github.io/post/lanqiao/</id>
        <link href="https://panker13.github.io/post/lanqiao/">
        </link>
        <updated>2021-11-04T12:06:34.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-蓝桥杯赛事简介">一. <a href="https://dasai.lanqiao.cn/">蓝桥杯</a>赛事简介</h1>
<p>蓝桥杯全国软件和信息技术专业人才大赛，是由<strong>工业和信息化部人才交流中心</strong>（是工信部的二级组织，是由工信部的背书的(๑•̀ㅂ•́)و✧）举办的全国性IT学科赛事。蓝桥杯也是一个<strong>编程和算法竞赛</strong>，考察的是参赛者的<strong>编程能力和算法功底</strong>。<strong>全国1200余所高校</strong>参赛，累计参赛人数超过<strong>40万</strong>人。蓝桥杯大赛连续两年被列入中国高等教育学会发布的“全国普通高校学科竞赛排行榜”，是高校教育教学改革和创新人才培养的重要竞赛项目。对大学生<strong>综合评测，奖学金评定，升学考研</strong>都有一定助益。</p>
<p>大赛共包括三个竞赛组别，<strong>个人赛-软件类</strong>，个人赛-电子类，以及视觉艺术大赛。其中个人赛-软件类的比赛科目包括<strong>C/C++程序设计</strong>、Java软件开发、Python程序设计。今年第十二届蓝桥杯报名时间是<strong>2021年10月12日-2021年12月17日，4月省赛，5月国赛。</strong></p>
<p>蓝桥杯大赛已成功举办12届，成为国内始终领跑的人才培养选拔模式，并受到行业和企业的高度认可，<strong>含金量也逐年增加</strong>，主要体现在：</p>
<ul>
<li>蓝桥杯大赛题目的专业度高，专业度和难度已经与国际国内知名程序设计类竞赛不相上下。</li>
<li>双一流大学的参与度逐年提高，以最近的第11届蓝桥杯大赛为例，来自双一流大校的参赛选手近10000名；</li>
<li>专业顶尖选手越来越多，对历年选手的跟踪回访，发现大赛选手与ACM参赛选手高度重叠，可谓赢家通吃。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://imgtu.com/i/ImttC6" alt="" loading="lazy"></figure>
<h1 id="二-参加蓝桥杯的好处">二. 参加蓝桥杯的好处</h1>
<p>大学，是人生中最美最重要的时段。在大学，有的人经历苍白，有的人经历丰富，究竟是苍白还是丰富，取决于人的选择。如果你是IT类的学生，那么，我建议你了解并参加蓝桥杯大赛。既然我这么建议，那肯定是有道理的，比如：</p>
<h3 id="1-可以丰富自己的大学经历">1. 可以丰富自己的大学经历</h3>
<p>有的人，在大学失去了方向和斗志，浑浑噩噩，当初信誓旦旦要从事IT相关领域，最后发现，是从事打游戏这个领域，毕业前才发现，自己所学甚少。 而蓝桥杯大赛，恰好可以让你丰富自己的大学经历，不枉费专业，不虚此行。</p>
<h3 id="2-可以提供自己的实力和水平">2. 可以提供自己的实力和水平</h3>
<p>有不少同学是很有上进心的，但苦于不知道怎么发力。那么，蓝桥杯大赛，能给你指引好方向，让你处在竞争的氛围中，牵引着你向前。通过大赛实战，不断地检验和完善自己，经历挫败和曲折后，获得成功，这种经历，尤为珍贵。</p>
<h3 id="3-可以为将来的职业铺好道路">3. 可以为将来的职业铺好道路</h3>
<p>大家都是要去求职的，在面试中，最忌讳的就是，拿不出曾经的经历和成绩，无法打动面试官和公司。有的人在面试时，只说自己爱好学习，但拿不出任何证据。相反，如果参加蓝桥杯这样的大赛，成功也好，失败也好，至少来讲，你比别人多了一块敲门砖，面试官也会对你刮目相看。</p>
<p><img src="https://imgtu.com/i/Imt8ER" alt="" loading="lazy"><br>
<img src="https://imgtu.com/i/ImtGU1" alt="" loading="lazy"><br>
<img src="https://imgtu.com/i/ImtJ4x" alt="" loading="lazy"></p>
<h1 id="三-蓝桥杯的比赛形式">三. 蓝桥杯的比赛形式</h1>
<p>蓝桥杯为<strong>个人赛</strong>，一共有<strong>十道题目</strong>，题目类型一般是<strong>填空+编程题</strong>，比赛<strong>时长为4个小时</strong>，<strong>题目难度顺序一般按照由易到难</strong>。前面几道题目一般是给出题面问一个特定的答案，只需要在本地计算然后提交答案。后面的题目就是需要提交代码，跑通给定的案例，也就是OJ的形式（是OI形式）。题目完全为客观题型，选手所提交作答的运行结果为主要评分依据，比赛不能携带纸质资料。<br>
蓝桥杯的比赛组别分为：研究生组（研究生）、A组（985、211及以下）、<strong>B组</strong>（本科及以下）、C组（高职高专、中职中专）<br>
<a href="https://dasai.lanqiao.cn/pages/dasai/competition/competition_info.html?c=1">更详细的竞赛规则请戳我( ‘-ωก̀ )</a></p>
<h1 id="四-蓝桥杯的准备">四. 蓝桥杯的准备</h1>
<p>As is known to everyone，蓝桥杯是一个算法竞赛，而巧的是，咱正好也是一个算法算法交流群qaq。所以大家有什么算法相关的问题都可以尽管在群里问，我们配有<strong>oi大佬，金牌acmer，蓝桥杯国一</strong>选手为你助力，好几尊金光闪闪的大神坐镇给你找bug！而且幸运的是，咱学校最近的算法竞赛正处于一个迅速上升、茁壮成长的时期。蓝桥杯从以前的艰难省一到现在的国奖“有手就行”；ccpc、icpc从以前的“打铁”、“险铜”，到如今的争金夺银，这正是咱学校、咱院最近一年内发生的事。因此，群里的各位学长（弟）都有着丰富的备赛经验，而且各位大佬都是又帅气（美丽）又有爱心的，因此大家提出的问题他（她）们肯定会耐心解答的（ヽ(✿ﾟ▽ﾟ)ノ）。但是希望大家遇到问题是先不要太过于急于寻求别人的帮助的，还是尽量的先自己动手查查<a href="https://www.baidu.com/">Baidu</a>、<a href="https://cn.bing.com/">Bing</a>、<a href="https://www.google.com/">Google（如果谷歌不行就前两个吧qaq）</a>，然后再去<a href="https://www.csdn.net/">CSDN</a>或者<a href="https://www.cnblogs.com/">博客园</a>去看看，当然，有余力的同学也可以去<a href="https://stackoverflow.com/?newreg=2d426481155f47f69fd04de4101a1214">Stack Overflow（如果SO不行那就前两个吧qwq）</a>。如果真的不行，那也非常欢迎大家来群里一起讨论ヾ(´∀`o)+。</p>
<p>至于训练计划的话，我们建议：</p>
<ul>
<li>Step1. 先初步刷完<a href="http://211.84.203.11/">学校oj</a>上的前100题，最好再写几道结构体。</li>
<li>Step2. 跟着每周的郑轻新生赛做比赛训练，平台为<a href="http://acm.zzuli.edu.cn/contest.php?category=1">zzulioj竞赛栏目</a>，注：此步可与Step1并行</li>
<li>Step3. 等大家感觉自己水平差不多的时候，咱们就可以考虑开始写往年蓝桥杯比赛的真题了，方向，学长（弟）会为大家讲解其中的重难题的。</li>
</ul>
<h1 id="天上的星星有很多要相信自己也是天上闪闪的那一颗希望日后大家准备蓝桥杯的过程中里能够体会到算法的乐趣所在oツ">天上的星星有很多，要相信自己也是天上闪闪的那一颗，希望日后大家准备蓝桥杯的过程中里能够体会到算法的乐趣所在o(*≧▽≦)ツ！</h1>
<blockquote>
<p>本文部分内容转自博主：涛歌依旧</p>
<blockquote>
<p>https://blog.csdn.net/stpeace/article/details/114995926</p>
</blockquote>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[13届河南省省赛]]></title>
        <id>https://panker13.github.io/post/13-jie-he-nan-sheng-sheng-sai/</id>
        <link href="https://panker13.github.io/post/13-jie-he-nan-sheng-sheng-sai/">
        </link>
        <updated>2021-05-23T11:41:32.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-cpp">13届河南省省赛I题（dfs）

# include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;string&gt;
# include&lt;cstring&gt;

using namespace std;

int a[10];
int g[10];

int to1(int i)
{
    return (i+2)%8+1;
}

int to2(int i)
{
    return (i+4)%8+1;
}

bool dfs(int x, int num)
{
    g[x] = 1;
    if(num==8)
    {
        return true;
    }
    
    for(int i=1; i&lt;=8; ++i)
    {
        if(!g[i])
        {
            if(g[to1(i)])   return false;
            else   return dfs(g[to1(i)], num+1);
            
            if(g[to2(i)])   return false;
            else   return dfs(g[to2(i)], num+1);
        }
    }
}

int main()
{
    int t;
    cin&gt;&gt;t;
    
    while(t--)
    {
        int num = 0;
        bool cha = false;
        string s;
        cin&gt;&gt;s;
        for(int i=0; i&lt;8; ++i)
            if(s[i]=='1')
            {
                num++;
                a[i+1] = 1;
            }
            else   a[i+1] = 0;
        
        if(num==8)
        {
            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
            continue;
        }
        
        for(int i=1; i&lt;=8; ++i)
        {
            memcpy(g, a, sizeof a);
            
            if(!g[i])
            {
                if(g[to1(i)])   continue;
                else
                {
                    if(dfs(g[to1(i)], num+1))
                        cha = true;
                }
                
                if(g[to2(i)])   continue;
                else
                {
                    if(dfs(g[to2(i)], num+1))
                        cha = true;
                }
                
                if(cha)   break;
            }
        }
    
        if(cha)   cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
        else   cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
    }
    
    return 0;
}
</code></pre>
<pre><code class="language-cpp">//L题
# include&lt;iostream&gt;
# include&lt;algorithm&gt;

using namespace std;

bool ck(double a, double b, double x, double y)
{
    if(b*b*x*x + a*a*y*y &lt;= a*a*b*b)   return true;
    else   return false;
}

int main()
{
    int t;
    cin&gt;&gt;t;
    
    while(t--)
    {
        double cnt = 0, num = 0;
        double a1, b1, a2, b2;
        cin&gt;&gt;a1&gt;&gt;b1&gt;&gt;a2&gt;&gt;b2;
        
        for(double i=-8; i&lt;=8; i+=0.005)
            for(double j=-8; j&lt;=8; j+=0.005)
            {
                if(ck(a1, b1, i, j) || ck(a2, b2, i, j))   cnt++;
                num++;
            }
        
        double ans = cnt*1.0/40000*1.0;
        
        printf(&quot;%.1f\n&quot;, ans);
    }
    
    return 0;
}
</code></pre>
<p>J题：甜甜圈</p>
<pre><code class="language-cpp"># include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;cmath&gt;

using namespace std;

const int N = 1e5+10;

struct Range
{
    int val, num;
    bool operator&lt; (const Range &amp;w)const
    {
        return val &gt; w.val;
    }
}range[N];

int n, m;
int a1[N], a2[N], b[N];
int tr[N];

int lowbit(int x)
{
    return x &amp; -x;
}

void modify(int x, int v)
{
    for(int i=x; i&lt;=N; i+=lowbit(i))   tr[i] += v;
}

int query(int x)
{
    int res = 0;
    for(int i=x; i; i-=lowbit(i))   res += tr[i];
    return res;
}

int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1; i&lt;=n+m; ++i)   modify(i, 1);
    for(int i=1; i&lt;=n; ++i)   cin&gt;&gt;a1[i];
    for(int i=1; i&lt;=m; ++i)
    {
        cin&gt;&gt;a2[i];
        range[i] = {a2[i], i};
    }
    
    for(int i=n, j=m+1; i; --i, ++j)
        range[j] = {a1[i], j};
    
    sort(range+1, range+n+m+1);
    
    int l, r;
    int xx = range[1].num;
    if(xx&gt;m)   r = m;
    else   r = m+1;
    
    int ans = 0;
    for(int i=1; i&lt;=n+m; ++i)
    {
        int x = range[i].num;
        l = r, r = x;
        
        // cout&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;endl;
        
        modify(r, -1);
        int res = abs(query(r)-query(l));
        // cout&lt;&lt;res&lt;&lt;endl;
        ans += res;
        
    }
    // cout&lt;&lt;endl;
    cout&lt;&lt;ans&lt;&lt;endl;
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HUEL_ACM第二学期第六周：线性DP]]></title>
        <id>https://panker13.github.io/post/huel_acm-di-er-xue-qi-di-liu-zhou-xian-xing-dp/</id>
        <link href="https://panker13.github.io/post/huel_acm-di-er-xue-qi-di-liu-zhou-xian-xing-dp/">
        </link>
        <updated>2021-04-07T12:59:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="a-最长公共子序列模板-poj-1458">A - （最长公共子序列模板） POJ - 1458</h3>
<pre><code># include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 555;

char a[N], b[N];

int main()
{
    while(cin&gt;&gt;a+1&gt;&gt;b+1)            //读入字符串a，b
    {
        int dp[N][N];                       //定义答案数组dp
        //dp[i][j]是字串a的前i个字符与字串b的前j个字符的最长公共子序列
        
        int n = strlen(a+1), m = strlen(b+1);
        
        for(int i=1; i&lt;=n; ++i)
        {
            for(int j=1; j&lt;=m; ++j)
            {
                dp[i][j] = max(dp[i][j-1], dp[i-1][j]);     
                //如果两个字串最后一个数不相同，就取它们之前的最长公共子序列

                if(a[i]==b[j])   dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1);
                //如果最后两个字串的最后一个数相同，最长公共子序列可能为a前i-1个字符与b的前j-1个字符的最长公共子序列再+1
            }
        }
        
        cout&lt;&lt;dp[n][m]&lt;&lt;endl;           //根据定义，输出答案
    }
    
    return 0;
}
</code></pre>
<h3 id="b-思维-hdu-1003">B - （思维？） HDU - 1003</h3>
<p>主要思想：如果当前连续子序列的值为正值，那么无论它再加任何数，其总值都会大于它要加的数；如果当前连续子序列的值为负数，那么无论它再加任何数，其总值都会小于它要加的数。因此只有当当前子序列为正值的时候，该连续子序列的值才有可能增加，若为负数，则一定减小。所有当连续子序列的值为负数时，及时舍去该序列，重新再开一段序列（新序列的初始总值为0）</p>
<pre><code># include&lt;iostream&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 1e5+10;

struct Num
{
    int num, val;
}mini;

int t;
int a[N], s[N];

int main()
{
    cin&gt;&gt;t;
    for(int i=1; i&lt;=t; ++i)
    {
        memset(a, 0, sizeof a);
        memset(s, 0, sizeof s);
        
        cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;endl;
        int n;
        cin&gt;&gt;n;
    
        for(int i=1; i&lt;=n; ++i)   cin&gt;&gt;a[i];
        
        int l = 1, r = 1, ls = 1;
        int ans = -2e9, res = 0;
        for(int i=1; i&lt;=n; ++i)
        {
            res += a[i];
            
            if(res &gt; ans)
            {
                ans = res;
                r = i;
                ls = l;
            }
            
            if(res &lt; 0)
            {
                res = 0;
                l = i+1;
            }
        }
        
        cout&lt;&lt;ans&lt;&lt;' '&lt;&lt;ls&lt;&lt;' '&lt;&lt;r&lt;&lt;endl;
        if(i != t)   cout&lt;&lt;endl;
    }
    
    return 0;
}
</code></pre>
<h3 id="d-最长上升子序列模板-hdu-1087">D - （最长上升子序列模板） HDU - 1087</h3>
<pre><code>//注意题目的数据范围，可能会爆int

# include&lt;iostream&gt;
# include&lt;algorithm&gt;

using namespace std;

const long long N = 1100;

long long n;
long long a[N];
long long dp[N];        //dp[i]是以第i个数字为结尾的最长上升子序列和

int main()
{
    while(cin&gt;&gt;n, n)
    {
        for(long long i=1; i&lt;=n; ++i)   cin&gt;&gt;a[i];
        
        for(long long i=1; i&lt;=n; ++i)   dp[i] = a[i];      
         //初始化，每个数都是一个子序列，每个格子的上升子序列的和都至少是自己
        
        for(long long i=1; i&lt;=n; ++i)
        {
            for(long long j=1; j&lt;i; ++j)
            {
                if(a[j] &lt; a[i])   dp[i] = max(dp[i], dp[j]+a[i]);
                //如果j到i是上升子序列，那么取最值
            }
        }
        
        //根据定义的dp数组的含义，求出最值
        //注意：拥有最大和的上升子序列不一定是以原数组的最后一个数结尾，咱也不知道是以哪个数结尾，因此需遍历一遍整个数组，找出拥有最大和上升子序列
        long long ans = -2e18;
        for(long long i=1; i&lt;=n; ++i)   ans = max(ans, dp[i]);
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    
    return 0;
}
</code></pre>
<h3 id="f-最长上升子序列的优化-计蒜客-t2146">F - （最长上升子序列的优化） 计蒜客 - T2146</h3>
<pre><code>//对于拦截的每一个导弹，都有两种选择
//1. 使用之前的导弹拦截系统（前提是该导弹高度必须小于之前的导弹高度）
//2. 在开一个新的导弹拦截系统

# include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 1e5+10;

int n;
int a[N];
int dp[N];
int f[N];

int main()
{
    int cnt = 1;
    while(cin&gt;&gt;a[cnt])  cnt++;          //  &lt;cnt
    cnt--;
    
    //最长下降子（非上升）序列
    memset(dp, 0x3f, sizeof dp);
    for(int i=cnt; i; --i)
    {
        int x = a[i];
        int j = upper_bound(dp, dp+cnt, x)-dp;
        dp[j] = x;
    }
    int res = 0;
    while(dp[res]!=0x3f3f3f3f)   res++;
    cout&lt;&lt;res&lt;&lt;endl;
    
    
    //永远维护一个递增的序列
    //贪心：能不创建新的导弹拦截系统就不创建新的导弹拦截系统
    memset(f, 0x3f, sizeof f);
    
    for(int i=1; i&lt;=cnt; ++i)
    {
        int x = a[i];
        int j = lower_bound(f, f+cnt, x)-f;
        f[j] = x;
    }
    res = 0;
    while(f[res]!=0x3f3f3f3f)   res++;
    cout&lt;&lt;res&lt;&lt;endl;
    
    return 0;
}

</code></pre>
<h3 id="g-数字三角形的变形-计蒜客-t2153">G - （数字三角形的变形） 计蒜客 - T2153</h3>
<p><a href="https://www.acwing.com/problem/content/solution/1029/1/">他山之玉</a></p>
<pre><code># include&lt;iostream&gt;
# include&lt;algorithm&gt;

using namespace std;

const int N = 30;

int n;
int dp[N&lt;&lt;1][N][N];     //总坐标是i，a的横坐标是j，b的横坐标是k
int g[N][N];

int main()
{
    cin&gt;&gt;n;
    int a, b, c;
    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c, a||b||c)   g[a][b] = c;
    
    for(int i=2; i&lt;=(n&lt;&lt;1); ++i)
    {
        for(int j=1; j&lt;=n; ++j)
        {
            for(int k=1; k&lt;=n; ++k)
            {
                if(j&gt;=i || k&gt;=i)   continue;
                if(j==k)
                {
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+g[j][i-j]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+g[j][i-j]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]+g[j][i-j]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+g[j][i-j]);
                }
                else
                {
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+g[j][i-j]+g[k][i-k]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+g[j][i-j]+g[k][i-k]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]+g[j][i-j]+g[k][i-k]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+g[j][i-j]+g[k][i-k]);
                }
            }
        }
    }
    
    cout&lt;&lt;dp[n&lt;&lt;1][n][n]&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<h3 id="h-用一下逆向思维写法同上-计蒜客-t2091">H - （用一下逆向思维，写法同上） 计蒜客 - T2091</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML常见标签]]></title>
        <id>https://panker13.github.io/post/html-chang-jian-biao-qian/</id>
        <link href="https://panker13.github.io/post/html-chang-jian-biao-qian/">
        </link>
        <updated>2021-04-02T12:56:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="aa"><a></a></h3>
<ol>
<li>
<p>a&gt;是超链接标签，主要用于链接到另一个页面上</p>
</li>
<li>
<p>其主要属性有：herf, target, title</p>
</li>
<li>
<p>herf属性：a&gt;标签最重要的标签，作用：规定页面指向的URL（统一资源定位器）</p>
</li>
<li>
<p>关于URL：   URL指的是统一资源定位符（Uniform Resource Locator）。<br>
URL无非就是一个给定的独特资源在Web上的地址。理论上说，每个有效的URL都指向一个独特的资源。这个资源可以是一个HTML页面，一个CSS文档，一幅图像，等等。而在实际中，有一些例外，最常见的情况就是URL指向了不存在的或是被移动过的资源。由于通过URL呈现的资源和URL本身由Web服务器处理，因此web服务器的拥有者需要认真地维护资源以及与它关联的URL。<br>
作为一个小白，看到这个高级的专业词汇时，我是懵的，经过各方面搜索后，终于有了一点点认识，不容易！！<br>
我浅显的把它理解为——网址（不是我，是我抄的博客）<br>
示例：https://www.acwing.com/activity/content/21/<br>
下面来分析一下它的几个部分：<br>
1、http:// ——HTTP协议（超文本转移协议），当然也可以是其他协议。（https是一种更加安全的传输协议）<br>
2、www.baidu.com ——域名，表明在访问哪个服务器，当然也可以用IP地址代替。<br>
（其中www是指一个特定的服务器（万维网）），acwing.com是域名<br>
3、:80 —— 端口，用于访问Web服务器上的资源的技术“门”。（默认80，可能不写）<br>
4、/path/to/myfile.html —— 网络服务器上资源的路径（从根文件夹到这个资源的绝对路径）。<br>
5、?key1=value1&amp;key2=value2 —— 提供给网络服务器的额外参数。这些参数用&amp;分隔开。<br>
6、#SomewhereInTheDocument —— 资源本身的另一部分的锚点，锚点像一个迅速定位器一样，可以在网页中设置标记，然后创建链接，创建的链接可以使我们迅速访问到指定位置（想到了书签~~）</p>
</li>
<li>
<p>target属性：规定在何处打开链接文档。它有五个选项：<br>
　    _blank：在新窗口中打开被链接文档。<br>
　　_self：默认。在相同的框架中打开被链接文档。<br>
　　_parent：在父框架集中打开被链接文档。<br>
　　_top：在整个窗口中打开被链接文档。<br>
　　framename：在指定的框架中打开被链接文档。</p>
</li>
<li>
<p>title属性：一般用作给该元素加一个工具提示</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://panker13.github.io/post/hello-gridea/</id>
        <link href="https://panker13.github.io/post/hello-gridea/">
        </link>
        <updated>2021-03-23T11:39:35.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于搭建个人博客的经验]]></title>
        <id>https://panker13.github.io/post/guan-yu-da-jian-ge-ren-bo-ke-de-jing-yan/</id>
        <link href="https://panker13.github.io/post/guan-yu-da-jian-ge-ren-bo-ke-de-jing-yan/">
        </link>
        <updated>2021-03-23T11:11:19.000Z</updated>
        <summary type="html"><![CDATA[<p>在我用简单的方法失败了一次后，我终于用更简单的方法搭建好了我的第一个个人博客😝233</p>
]]></summary>
        <content type="html"><![CDATA[<p>在我用简单的方法失败了一次后，我终于用更简单的方法搭建好了我的第一个个人博客😝233</p>
<!-- more -->
<h2 id="在210323的下午翘了体育课">在21.03.23的下午翘了体育课</h2>
<p>这无疑是我翘过最正确的一节课了😎。其实，搭建个人博客是我上学期就一直向干的事情了（主要是受到了许多博客的可爱的看板娘的<s>诱惑</s>，并且看到yyh同学的博客，我直接心生艳羡之意），所以我其实寒假在家已经尝试过利用Github托管服务与Hexo框架搭建个人博客了，但，，，失败了。但但，天无绝人之路，在某天的中午（对，就是上面的日期），我了解到了Gridea这个自助式搭建博客神器，成功拯救了我这个<s>手残党</s></p>
<h2 id="寒假的尝试">寒假的尝试</h2>
<p>在寒假，我用了整整一天的时间来了解Git、Node、Hexo等等（虽然现在都已经忘得差不多了），去尝试注册Github的仓库，初始化一个博客等等（这些都成功了，也算是有所收获），但是，却在将初始化的博客内容推送到Github上的时候失败了（现在想来可能是Github在国内的网络连接不稳定）。然后我把所有的Git、Node等软件全部删除了然后重装，如此反复三次，结果都gg了，唉😔。到现在还是nodejs下的某个组件安装失败，疑问仍未解决</p>
<h2 id="gridea">Gridea</h2>
<p>这软件可好，<s>傻瓜</s>自助式搭建博客助手（不过好像要备份，因为一换电脑，上面的内容就消失了），具体用法百度吧，哈哈，我累了，现在在上自习课（19：34），我还要写算法题呢，嘿嘿😁，再见，下次再聊（如果有下次的话）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法学习：从poj上的Fliptile到开关问题]]></title>
        <id>https://panker13.github.io/post/suan-fa-xue-xi-cong-poj-shang-de-fliptile-dao-kai-guan-wen-ti/</id>
        <link href="https://panker13.github.io/post/suan-fa-xue-xi-cong-poj-shang-de-fliptile-dao-kai-guan-wen-ti/">
        </link>
        <updated>2021-03-23T10:28:16.000Z</updated>
        <summary type="html"><![CDATA[<p>是一个关于二进制枚举以及模拟递推的小问题😳</p>
]]></summary>
        <content type="html"><![CDATA[<p>是一个关于二进制枚举以及模拟递推的小问题😳</p>
<!-- more -->
<h3 id="写在前面本人蒟蒻写此分享来督促自己复习并与大家分享有关开关问题的一些技巧以及例题代码">写在前面：本人蒟蒻，写此分享来督促自己复习，并与大家分享有关开关问题的一些技巧以及例题代码</h3>
<p><a href="http://poj.org/problem?id=3279">Fliptile题目链接</a><br>
<a href="https://yq.aliyun.com/articles/267150">参考题解</a><br>
<a href="https://blog.csdn.net/ac_hell/article/details/51077320">翻转问题的主要技巧以及规律</a></p>
<h3 id="详细内容见代码及注释">详细内容见代码及注释</h3>
<h3 id="代码如有疏漏之处敬请指出">代码（如有疏漏之处，敬请指出）😁</h3>
<pre><code>//先用状态压缩的方法枚举第一行的翻转情况，然后通过第一行的情况来递推出第二行的情况
//即：已知了第一行的情况了，需要通过第二行来修正第一行的情况
//（因为第一行已经被枚举固定了，所以除了第二行之外，其他行无法修改第一行）
//以此类推：其他所有行的情况都可以被递推出（即：是已经固定的了）
//注意：除了最后一行，因为没有最后一行没有下一行来帮最后一行修正
//(所以最后一行也是固定的，无法修正，最后应该检查一下最后一行是否符合题意即可)
//关键是：由下一行来处理上一行（而且是垂直的上一行，因为只有垂直的上一行是固定的）

# include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 20;
const int INF = 0x3f3f3f3f;

int n, m;
int a[N][N];            //原始数组
int b[N][N];            //保存翻转次数的数组
int c[N][N];            //记录答案的数组
int dx[] = {0, 1, 0, -1, 0}, dy[] = {0, 0, -1, 0, 1};   //其实棋子并不受下方棋子的影响

bool out(int x, int y)
{
    if(x &lt; 0 || x &gt;= n|| y &lt; 0 || y &gt;= m)  return true;
    else  return false;
}

int get_color(int x, int y)
{
    int color = a[x][y];                                //初始颜色（这里是a）
    for(int i=0; i&lt;5; ++i)
    {
        int nx = x + dx[i], ny = y + dy[i];
        if(out(nx, ny))  continue;
        color += b[nx][ny];                             //这里是b
    }
    return color &amp; 1;                                   //本层翻转后的颜色（是固定的）
    //翻转后的颜色等于初始颜色+翻转影响产生的颜色（上，下，左，右，中五个方向）
}

int flip(int s)
{
    for(int i=1; i&lt;=m; ++i)  b[0][i-1] = (s&gt;&gt;(m-i)) &amp; 1;
    
    for(int i=1; i&lt;n; ++i)
    {
        for(int j=0; j&lt;m; ++j)
        {
            if(get_color(i-1, j))   b[i][j] = 1;  
            //由上一行的状态来递推出下一行的状态，因为上一行的上，左，右状态已经全部已知
            //而正是由上方的状态来递推出其下方的状态
        }
    }
    
    for(int i=0; i&lt;m; ++i)   if(get_color(n-1, i))   return INF;        //检查最后一层
    
    int times = 0;
    for(int i=0; i&lt;n; ++i)   for(int j=0; j&lt;m; ++j)  times += b[i][j];  //得出最小翻转次数
    return times;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=0; i&lt;n; ++i)  for(int j=0; j&lt;m; ++j)   cin&gt;&gt;a[i][j];
    
    int ans = INF;
    //枚举的是第一行所有可能的翻转动作（即：翻(1)或不翻(0)）
    for(int i=0; i &lt; (1&lt;&lt;m); ++i)        //状态压缩，枚举第一行所有可能的情况 ，后面的只需递推了
    {
        memset(b, 0, sizeof b);         //记得初始化b
        int t = flip(i);
        if(t &lt; ans)
        {
            ans = t;
            memcpy(c, b, sizeof b);     //复制状态
        }
    }
    
    if(ans == INF)  cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl;
    else
    {
        for(int i=0; i&lt;n; ++i)
        {
            for(int j=0; j&lt;m; ++j)
            {
                cout&lt;&lt;c[i][j]&lt;&lt;' ';
            }
            cout&lt;&lt;endl;
        }
    }
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>