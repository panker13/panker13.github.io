<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://panker13.github.io</id>
    <title>Panker</title>
    <updated>2021-04-07T13:37:45.208Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://panker13.github.io"/>
    <link rel="self" href="https://panker13.github.io/atom.xml"/>
    <subtitle>春天的原野里，你一个人正走着，对面走来了一只可爱的小熊，浑身的毛活像天鹅绒，眼睛圆鼓鼓的。它这么对你说:你好，小姐，和我一块儿打滚玩好吗？接着，你就和小熊一起，顺着长满三叶草的山坡咕噜咕噜滚下去，整整玩了一天。</subtitle>
    <logo>https://panker13.github.io/images/avatar.png</logo>
    <icon>https://panker13.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Panker</rights>
    <entry>
        <title type="html"><![CDATA[HUEL_ACM第二学期第六周：线性DP]]></title>
        <id>https://panker13.github.io/post/huel_acm-di-er-xue-qi-di-liu-zhou-xian-xing-dp/</id>
        <link href="https://panker13.github.io/post/huel_acm-di-er-xue-qi-di-liu-zhou-xian-xing-dp/">
        </link>
        <updated>2021-04-07T12:59:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="a-最长公共子序列模板-poj-1458">A - （最长公共子序列模板） POJ - 1458</h3>
<pre><code># include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 555;

char a[N], b[N];

int main()
{
    while(cin&gt;&gt;a+1&gt;&gt;b+1)            //读入字符串a，b
    {
        int dp[N][N];                       //定义答案数组dp
        //dp[i][j]是字串a的前i个字符与字串b的前j个字符的最长公共子序列
        
        int n = strlen(a+1), m = strlen(b+1);
        
        for(int i=1; i&lt;=n; ++i)
        {
            for(int j=1; j&lt;=m; ++j)
            {
                dp[i][j] = max(dp[i][j-1], dp[i-1][j]);     
                //如果两个字串最后一个数不相同，就取它们之前的最长公共子序列

                if(a[i]==b[j])   dp[i][j] = max(dp[i][j], dp[i-1][j-1]+1);
                //如果最后两个字串的最后一个数相同，最长公共子序列可能为a前i-1个字符与b的前j-1个字符的最长公共子序列再+1
            }
        }
        
        cout&lt;&lt;dp[n][m]&lt;&lt;endl;           //根据定义，输出答案
    }
    
    return 0;
}
</code></pre>
<h3 id="b-思维-hdu-1003">B - （思维？） HDU - 1003</h3>
<p>主要思想：如果当前连续子序列的值为正值，那么无论它再加任何数，其总值都会大于它要加的数；如果当前连续子序列的值为负数，那么无论它再加任何数，其总值都会小于它要加的数。因此只有当当前子序列为正值的时候，该连续子序列的值才有可能增加，若为负数，则一定减小。所有当连续子序列的值为负数时，及时舍去该序列，重新再开一段序列（新序列的初始总值为0）</p>
<pre><code># include&lt;iostream&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 1e5+10;

struct Num
{
    int num, val;
}mini;

int t;
int a[N], s[N];

int main()
{
    cin&gt;&gt;t;
    for(int i=1; i&lt;=t; ++i)
    {
        memset(a, 0, sizeof a);
        memset(s, 0, sizeof s);
        
        cout&lt;&lt;&quot;Case &quot;&lt;&lt;i&lt;&lt;&quot;:&quot;&lt;&lt;endl;
        int n;
        cin&gt;&gt;n;
    
        for(int i=1; i&lt;=n; ++i)   cin&gt;&gt;a[i];
        
        int l = 1, r = 1, ls = 1;
        int ans = -2e9, res = 0;
        for(int i=1; i&lt;=n; ++i)
        {
            res += a[i];
            
            if(res &gt; ans)
            {
                ans = res;
                r = i;
                ls = l;
            }
            
            if(res &lt; 0)
            {
                res = 0;
                l = i+1;
            }
        }
        
        cout&lt;&lt;ans&lt;&lt;' '&lt;&lt;ls&lt;&lt;' '&lt;&lt;r&lt;&lt;endl;
        if(i != t)   cout&lt;&lt;endl;
    }
    
    return 0;
}
</code></pre>
<h3 id="d-最长上升子序列模板-hdu-1087">D - （最长上升子序列模板） HDU - 1087</h3>
<pre><code>//注意题目的数据范围，可能会爆int

# include&lt;iostream&gt;
# include&lt;algorithm&gt;

using namespace std;

const long long N = 1100;

long long n;
long long a[N];
long long dp[N];        //dp[i]是以第i个数字为结尾的最长上升子序列和

int main()
{
    while(cin&gt;&gt;n, n)
    {
        for(long long i=1; i&lt;=n; ++i)   cin&gt;&gt;a[i];
        
        for(long long i=1; i&lt;=n; ++i)   dp[i] = a[i];      
         //初始化，每个数都是一个子序列，每个格子的上升子序列的和都至少是自己
        
        for(long long i=1; i&lt;=n; ++i)
        {
            for(long long j=1; j&lt;i; ++j)
            {
                if(a[j] &lt; a[i])   dp[i] = max(dp[i], dp[j]+a[i]);
                //如果j到i是上升子序列，那么取最值
            }
        }
        
        //根据定义的dp数组的含义，求出最值
        //注意：拥有最大和的上升子序列不一定是以原数组的最后一个数结尾，咱也不知道是以哪个数结尾，因此需遍历一遍整个数组，找出拥有最大和上升子序列
        long long ans = -2e18;
        for(long long i=1; i&lt;=n; ++i)   ans = max(ans, dp[i]);
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    
    return 0;
}
</code></pre>
<h3 id="f-最长上升子序列的优化-计蒜客-t2146">F - （最长上升子序列的优化） 计蒜客 - T2146</h3>
<pre><code>//对于拦截的每一个导弹，都有两种选择
//1. 使用之前的导弹拦截系统（前提是该导弹高度必须小于之前的导弹高度）
//2. 在开一个新的导弹拦截系统

# include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 1e5+10;

int n;
int a[N];
int dp[N];
int f[N];

int main()
{
    int cnt = 1;
    while(cin&gt;&gt;a[cnt])  cnt++;          //  &lt;cnt
    cnt--;
    
    //最长下降子（非上升）序列
    memset(dp, 0x3f, sizeof dp);
    for(int i=cnt; i; --i)
    {
        int x = a[i];
        int j = upper_bound(dp, dp+cnt, x)-dp;
        dp[j] = x;
    }
    int res = 0;
    while(dp[res]!=0x3f3f3f3f)   res++;
    cout&lt;&lt;res&lt;&lt;endl;
    
    
    //永远维护一个递增的序列
    //贪心：能不创建新的导弹拦截系统就不创建新的导弹拦截系统
    memset(f, 0x3f, sizeof f);
    
    for(int i=1; i&lt;=cnt; ++i)
    {
        int x = a[i];
        int j = lower_bound(f, f+cnt, x)-f;
        f[j] = x;
    }
    res = 0;
    while(f[res]!=0x3f3f3f3f)   res++;
    cout&lt;&lt;res&lt;&lt;endl;
    
    return 0;
}

</code></pre>
<h3 id="g-数字三角形的变形-计蒜客-t2153">G - （数字三角形的变形） 计蒜客 - T2153</h3>
<p><a href="https://www.acwing.com/problem/content/solution/1029/1/">他山之玉</a></p>
<pre><code># include&lt;iostream&gt;
# include&lt;algorithm&gt;

using namespace std;

const int N = 30;

int n;
int dp[N&lt;&lt;1][N][N];     //总坐标是i，a的横坐标是j，b的横坐标是k
int g[N][N];

int main()
{
    cin&gt;&gt;n;
    int a, b, c;
    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c, a||b||c)   g[a][b] = c;
    
    for(int i=2; i&lt;=(n&lt;&lt;1); ++i)
    {
        for(int j=1; j&lt;=n; ++j)
        {
            for(int k=1; k&lt;=n; ++k)
            {
                if(j&gt;=i || k&gt;=i)   continue;
                if(j==k)
                {
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+g[j][i-j]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+g[j][i-j]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]+g[j][i-j]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+g[j][i-j]);
                }
                else
                {
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k]+g[j][i-j]+g[k][i-k]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k-1]+g[j][i-j]+g[k][i-k]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j][k]+g[j][i-j]+g[k][i-k]);
                    dp[i][j][k] = max(dp[i][j][k], dp[i-1][j-1][k-1]+g[j][i-j]+g[k][i-k]);
                }
            }
        }
    }
    
    cout&lt;&lt;dp[n&lt;&lt;1][n][n]&lt;&lt;endl;
    
    return 0;
}
</code></pre>
<h3 id="h-用一下逆向思维写法同上-计蒜客-t2091">H - （用一下逆向思维，写法同上） 计蒜客 - T2091</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTML常见标签]]></title>
        <id>https://panker13.github.io/post/html-chang-jian-biao-qian/</id>
        <link href="https://panker13.github.io/post/html-chang-jian-biao-qian/">
        </link>
        <updated>2021-04-02T12:56:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="aa"><a></a></h3>
<ol>
<li>
<p>a&gt;是超链接标签，主要用于链接到另一个页面上</p>
</li>
<li>
<p>其主要属性有：herf, target, title</p>
</li>
<li>
<p>herf属性：a&gt;标签最重要的标签，作用：规定页面指向的URL（统一资源定位器）</p>
</li>
<li>
<p>关于URL：   URL指的是统一资源定位符（Uniform Resource Locator）。<br>
URL无非就是一个给定的独特资源在Web上的地址。理论上说，每个有效的URL都指向一个独特的资源。这个资源可以是一个HTML页面，一个CSS文档，一幅图像，等等。而在实际中，有一些例外，最常见的情况就是URL指向了不存在的或是被移动过的资源。由于通过URL呈现的资源和URL本身由Web服务器处理，因此web服务器的拥有者需要认真地维护资源以及与它关联的URL。<br>
作为一个小白，看到这个高级的专业词汇时，我是懵的，经过各方面搜索后，终于有了一点点认识，不容易！！<br>
我浅显的把它理解为——网址（不是我，是我抄的博客）<br>
示例：https://www.acwing.com/activity/content/21/<br>
下面来分析一下它的几个部分：<br>
1、http:// ——HTTP协议（超文本转移协议），当然也可以是其他协议。（https是一种更加安全的传输协议）<br>
2、www.baidu.com ——域名，表明在访问哪个服务器，当然也可以用IP地址代替。<br>
（其中www是指一个特定的服务器（万维网）），acwing.com是域名<br>
3、:80 —— 端口，用于访问Web服务器上的资源的技术“门”。（默认80，可能不写）<br>
4、/path/to/myfile.html —— 网络服务器上资源的路径（从根文件夹到这个资源的绝对路径）。<br>
5、?key1=value1&amp;key2=value2 —— 提供给网络服务器的额外参数。这些参数用&amp;分隔开。<br>
6、#SomewhereInTheDocument —— 资源本身的另一部分的锚点，锚点像一个迅速定位器一样，可以在网页中设置标记，然后创建链接，创建的链接可以使我们迅速访问到指定位置（想到了书签~~）</p>
</li>
<li>
<p>target属性：规定在何处打开链接文档。它有五个选项：<br>
　    _blank：在新窗口中打开被链接文档。<br>
　　_self：默认。在相同的框架中打开被链接文档。<br>
　　_parent：在父框架集中打开被链接文档。<br>
　　_top：在整个窗口中打开被链接文档。<br>
　　framename：在指定的框架中打开被链接文档。</p>
</li>
<li>
<p>title属性：一般用作给该元素加一个工具提示</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://panker13.github.io/post/hello-gridea/</id>
        <link href="https://panker13.github.io/post/hello-gridea/">
        </link>
        <updated>2021-03-23T11:39:35.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于搭建个人博客的经验]]></title>
        <id>https://panker13.github.io/post/guan-yu-da-jian-ge-ren-bo-ke-de-jing-yan/</id>
        <link href="https://panker13.github.io/post/guan-yu-da-jian-ge-ren-bo-ke-de-jing-yan/">
        </link>
        <updated>2021-03-23T11:11:19.000Z</updated>
        <summary type="html"><![CDATA[<p>在我用简单的方法失败了一次后，我终于用更简单的方法搭建好了我的第一个个人博客😝233</p>
]]></summary>
        <content type="html"><![CDATA[<p>在我用简单的方法失败了一次后，我终于用更简单的方法搭建好了我的第一个个人博客😝233</p>
<!-- more -->
<h2 id="在210323的下午翘了体育课">在21.03.23的下午翘了体育课</h2>
<p>这无疑是我翘过最正确的一节课了😎。其实，搭建个人博客是我上学期就一直向干的事情了（主要是受到了许多博客的可爱的看板娘的<s>诱惑</s>，并且看到yyh同学的博客，我直接心生艳羡之意），所以我其实寒假在家已经尝试过利用Github托管服务与Hexo框架搭建个人博客了，但，，，失败了。但但，天无绝人之路，在某天的中午（对，就是上面的日期），我了解到了Gridea这个自助式搭建博客神器，成功拯救了我这个<s>手残党</s></p>
<h2 id="寒假的尝试">寒假的尝试</h2>
<p>在寒假，我用了整整一天的时间来了解Git、Node、Hexo等等（虽然现在都已经忘得差不多了），去尝试注册Github的仓库，初始化一个博客等等（这些都成功了，也算是有所收获），但是，却在将初始化的博客内容推送到Github上的时候失败了（现在想来可能是Github在国内的网络连接不稳定）。然后我把所有的Git、Node等软件全部删除了然后重装，如此反复三次，结果都gg了，唉😔。到现在还是nodejs下的某个组件安装失败，疑问仍未解决</p>
<h2 id="gridea">Gridea</h2>
<p>这软件可好，<s>傻瓜</s>自助式搭建博客助手（不过好像要备份，因为一换电脑，上面的内容就消失了），具体用法百度吧，哈哈，我累了，现在在上自习课（19：34），我还要写算法题呢，嘿嘿😁，再见，下次再聊（如果有下次的话）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算法学习：从poj上的Fliptile到开关问题]]></title>
        <id>https://panker13.github.io/post/suan-fa-xue-xi-cong-poj-shang-de-fliptile-dao-kai-guan-wen-ti/</id>
        <link href="https://panker13.github.io/post/suan-fa-xue-xi-cong-poj-shang-de-fliptile-dao-kai-guan-wen-ti/">
        </link>
        <updated>2021-03-23T10:28:16.000Z</updated>
        <summary type="html"><![CDATA[<p>是一个关于二进制枚举以及模拟递推的小问题😳</p>
]]></summary>
        <content type="html"><![CDATA[<p>是一个关于二进制枚举以及模拟递推的小问题😳</p>
<!-- more -->
<h3 id="写在前面本人蒟蒻写此分享来督促自己复习并与大家分享有关开关问题的一些技巧以及例题代码">写在前面：本人蒟蒻，写此分享来督促自己复习，并与大家分享有关开关问题的一些技巧以及例题代码</h3>
<p><a href="http://poj.org/problem?id=3279">Fliptile题目链接</a><br>
<a href="https://yq.aliyun.com/articles/267150">参考题解</a><br>
<a href="https://blog.csdn.net/ac_hell/article/details/51077320">翻转问题的主要技巧以及规律</a></p>
<h3 id="详细内容见代码及注释">详细内容见代码及注释</h3>
<h3 id="代码如有疏漏之处敬请指出">代码（如有疏漏之处，敬请指出）😁</h3>
<pre><code>//先用状态压缩的方法枚举第一行的翻转情况，然后通过第一行的情况来递推出第二行的情况
//即：已知了第一行的情况了，需要通过第二行来修正第一行的情况
//（因为第一行已经被枚举固定了，所以除了第二行之外，其他行无法修改第一行）
//以此类推：其他所有行的情况都可以被递推出（即：是已经固定的了）
//注意：除了最后一行，因为没有最后一行没有下一行来帮最后一行修正
//(所以最后一行也是固定的，无法修正，最后应该检查一下最后一行是否符合题意即可)
//关键是：由下一行来处理上一行（而且是垂直的上一行，因为只有垂直的上一行是固定的）

# include&lt;iostream&gt;
# include&lt;algorithm&gt;
# include&lt;cstring&gt;

using namespace std;

const int N = 20;
const int INF = 0x3f3f3f3f;

int n, m;
int a[N][N];            //原始数组
int b[N][N];            //保存翻转次数的数组
int c[N][N];            //记录答案的数组
int dx[] = {0, 1, 0, -1, 0}, dy[] = {0, 0, -1, 0, 1};   //其实棋子并不受下方棋子的影响

bool out(int x, int y)
{
    if(x &lt; 0 || x &gt;= n|| y &lt; 0 || y &gt;= m)  return true;
    else  return false;
}

int get_color(int x, int y)
{
    int color = a[x][y];                                //初始颜色（这里是a）
    for(int i=0; i&lt;5; ++i)
    {
        int nx = x + dx[i], ny = y + dy[i];
        if(out(nx, ny))  continue;
        color += b[nx][ny];                             //这里是b
    }
    return color &amp; 1;                                   //本层翻转后的颜色（是固定的）
    //翻转后的颜色等于初始颜色+翻转影响产生的颜色（上，下，左，右，中五个方向）
}

int flip(int s)
{
    for(int i=1; i&lt;=m; ++i)  b[0][i-1] = (s&gt;&gt;(m-i)) &amp; 1;
    
    for(int i=1; i&lt;n; ++i)
    {
        for(int j=0; j&lt;m; ++j)
        {
            if(get_color(i-1, j))   b[i][j] = 1;  
            //由上一行的状态来递推出下一行的状态，因为上一行的上，左，右状态已经全部已知
            //而正是由上方的状态来递推出其下方的状态
        }
    }
    
    for(int i=0; i&lt;m; ++i)   if(get_color(n-1, i))   return INF;        //检查最后一层
    
    int times = 0;
    for(int i=0; i&lt;n; ++i)   for(int j=0; j&lt;m; ++j)  times += b[i][j];  //得出最小翻转次数
    return times;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    
    cin&gt;&gt;n&gt;&gt;m;
    
    for(int i=0; i&lt;n; ++i)  for(int j=0; j&lt;m; ++j)   cin&gt;&gt;a[i][j];
    
    int ans = INF;
    //枚举的是第一行所有可能的翻转动作（即：翻(1)或不翻(0)）
    for(int i=0; i &lt; (1&lt;&lt;m); ++i)        //状态压缩，枚举第一行所有可能的情况 ，后面的只需递推了
    {
        memset(b, 0, sizeof b);         //记得初始化b
        int t = flip(i);
        if(t &lt; ans)
        {
            ans = t;
            memcpy(c, b, sizeof b);     //复制状态
        }
    }
    
    if(ans == INF)  cout&lt;&lt;&quot;IMPOSSIBLE&quot;&lt;&lt;endl;
    else
    {
        for(int i=0; i&lt;n; ++i)
        {
            for(int j=0; j&lt;m; ++j)
            {
                cout&lt;&lt;c[i][j]&lt;&lt;' ';
            }
            cout&lt;&lt;endl;
        }
    }
    
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>